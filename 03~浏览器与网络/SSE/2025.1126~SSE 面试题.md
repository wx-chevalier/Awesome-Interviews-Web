### 一、基础概念题

#### 1. 什么是 SSE（Server-Sent Events）？它的核心用途是什么？

**参考答案**：
SSE 是基于 HTTP 的服务器向客户端单向推送实时数据的技术，属于 HTML5 规范的一部分。它允许服务器主动向已建立长连接的客户端发送文本型事件流，无需客户端频繁轮询。
核心用途：适用于**单向实时数据推送场景**，比如实时日志、股票行情、新闻推送、系统监控数据、聊天消息接收（仅服务端推客户端）等。

#### 2. SSE 的通信模式是怎样的？和 HTTP 常规请求有什么区别？

**参考答案**：

- 通信模式：**服务器单向推送、客户端被动接收** 的单工通信；基于 HTTP 长连接，连接建立后服务器可多次向客户端发送数据，直到连接关闭。
- 与常规 HTTP 请求的区别：
  1. 常规 HTTP 是“请求-响应”短连接，客户端发请求 → 服务器回响应 → 连接关闭；
  2. SSE 是 HTTP 长连接，响应头为`Content-Type: text/event-stream`，服务器可分批次（流）向客户端发送数据，连接持续至主动关闭；
  3. SSE 内置重连机制，常规 HTTP 无。

#### 3. SSE 的消息格式有哪些要求？常见的字段有哪些？

**参考答案**：
SSE 消息必须遵循特定文本格式，每行以`字段名: 值`组成，空行表示消息结束。
常见字段：

- `data`：消息主体（核心），可多行（每行`data: 内容`），多行最终拼接为一个字符串；
- `event`：自定义事件类型（默认`message`），前端可通过`addEventListener('自定义类型', ...)`监听；
- `id`：消息 ID，用于客户端记录最后接收的消息 ID（`lastEventId`），重连时会通过 HTTP 请求头`Last-Event-ID`携带，服务器可据此补发丢失的消息；
- `retry`：自定义重连间隔（毫秒），覆盖默认重连时间；
- 注释行：以`:`开头，用于心跳/保活（无实际意义，仅维持连接）。

示例：

```
event: update
id: 1001
data: {"price": 99.9}
data: {"time": "2025-11-26"}

: 心跳保活
```

### 二、核心原理题

#### 1. SSE 是基于 HTTP 的，它是如何实现服务器主动推送数据的？

**参考答案**：
SSE 本质是利用 HTTP 的**流式响应（Chunked Transfer Encoding）** 实现：

1. 客户端发送普通 HTTP GET 请求，请求头指定接受`text/event-stream`；
2. 服务器返回响应时，设置`Transfer-Encoding: chunked`（分块传输），且不关闭连接；
3. 服务器将数据拆分为多个“块”，逐块向客户端发送（每块符合 SSE 消息格式）；
4. 客户端解析流数据，实时处理每一个消息块，连接保持开放，直到服务器/客户端主动关闭。

核心：HTTP 分块传输允许服务器在响应中分批发送数据，突破了“一次请求一次响应”的限制，模拟出“主动推送”的效果。

#### 2. SSE 的连接是长连接还是短连接？底层是如何维持连接的？

**参考答案**：

- SSE 是**HTTP 长连接**，默认连接会持续至客户端关闭（如关闭页面）或服务器主动断开。
- 连接维持方式：
  1. 服务器定期发送**注释行（: 心跳）**：若长时间无业务数据，服务器发送空注释行，避免中间件（如 Nginx）因超时断开连接；
  2. 客户端内置重连机制：若连接意外断开，客户端会按默认（或`retry`指定）间隔自动重连；
  3. 协议层面：HTTP 长连接依赖`Connection: keep-alive`响应头（HTTP/1.1 默认开启），保持 TCP 连接不关闭。

#### 3. SSE 的重连机制是怎样的？可以自定义重连逻辑吗？

**参考答案**：

- 默认重连机制：
  1. 当 SSE 连接意外断开（如网络中断、服务器重启），客户端会自动触发重连；
  2. 默认重连间隔约 3 秒，重连时客户端会在请求头携带`Last-Event-ID`（最后接收的`id`字段值）；
  3. 服务器可通过`Last-Event-ID`识别客户端丢失的消息，补发数据。
- 自定义重连：
  1. 服务器通过`retry`字段指定重连间隔（如`retry: 5000`表示 5 秒重连）；
  2. 前端可覆盖默认逻辑：监听`error`事件后手动关闭默认重连（`eventSource.close()`），再自定义定时器实现重连（如指数退避策略）；
  3. 前端可通过`eventSource.lastEventId`获取最后接收的消息 ID，重连时手动携带。

### 三、实操使用题

#### 1. 请写出前端使用 SSE 的基本代码示例。

**参考答案**：

```javascript
// 1. 创建SSE连接
const eventSource = new EventSource("/api/sse");

// 2. 监听默认消息（event未指定时）
eventSource.onmessage = (e) => {
  console.log("默认消息:", e.data);
};

// 3. 监听自定义事件（如update）
eventSource.addEventListener("update", (e) => {
  console.log("自定义update事件:", JSON.parse(e.data));
});

// 4. 监听错误（含连接断开）
eventSource.onerror = (e) => {
  if (eventSource.readyState === EventSource.CLOSED) {
    console.log("连接已关闭");
  } else if (eventSource.readyState === EventSource.CONNECTING) {
    console.log("正在重连...");
  } else {
    console.error("连接错误:", e);
  }
};

// 5. 手动关闭连接（如页面卸载时）
window.addEventListener("beforeunload", () => {
  eventSource.close();
});
```

#### 2. 后端（Node.js/Express）实现 SSE 服务端推送示例

**参考答案**：

```javascript
const express = require("express");
const app = express();

// 解决跨域
app.use((req, res, next) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "Last-Event-ID");
  next();
});

// SSE接口
app.get("/api/sse", (req, res) => {
  // 设置SSE响应头
  res.writeHead(200, {
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache", // 禁止缓存
    Connection: "keep-alive",
    "Transfer-Encoding": "chunked",
  });

  // 记录客户端最后接收的消息ID（重连时）
  const lastEventId = req.headers["last-event-id"] || 0;
  let currentId = parseInt(lastEventId) + 1;

  // 1. 补发丢失的消息（可选）
  if (lastEventId > 0) {
    res.write(`id: ${lastEventId}\n`);
    res.write(`data: 补发消息-${lastEventId}\n\n`);
  }

  // 2. 定时推送业务数据
  const timer = setInterval(() => {
    // 构造SSE消息
    const message = {
      price: Math.random() * 100,
      time: new Date().toLocaleString(),
    };
    // 发送自定义事件+ID+数据
    res.write(`event: update\n`);
    res.write(`id: ${currentId}\n`);
    res.write(`data: ${JSON.stringify(message)}\n\n`);
    currentId++;

    // 心跳保活（每30秒发送一次，无业务数据时）
    // res.write(`: heartbeat\n\n`);
  }, 2000);

  // 3. 监听客户端断开连接，清理定时器
  req.on("close", () => {
    clearInterval(timer);
    res.end();
    console.log("客户端断开SSE连接");
  });
});

app.listen(3000, () => {
  console.log("SSE服务启动：http://localhost:3000");
});
```

#### 3. 如何关闭 SSE 连接？前端和后端分别需要注意什么？

**参考答案**：

- 前端关闭：

  1. 调用`eventSource.close()`，此时`readyState`变为`CLOSED`，客户端不会自动重连；
  2. 需在页面卸载（`beforeunload`）、路由切换时主动关闭，避免无效长连接占用资源；
  3. 关闭后无法复用该`EventSource`实例，需重新创建。

- 后端关闭：
  1. 监听请求的`close`事件（如 Node.js 的`req.on('close', ...)`），清理定时器/资源，避免内存泄漏；
  2. 服务器主动断开时，可发送`data: close\n\n`消息，前端监听后主动`close()`；
  3. 避免强制关闭 TCP 连接（如`res.destroy()`），优先正常`res.end()`。

### 四、对比选型题

#### 1. SSE 和 WebSocket 有什么区别？各自的适用场景是什么？

| 维度     | SSE                           | WebSocket                       |
| -------- | ----------------------------- | ------------------------------- |
| 通信模式 | 单工（服务器 → 客户端）       | 全双工（双向通信）              |
| 协议基础 | 基于 HTTP（兼容现有 HTTP 栈） | 独立的 WebSocket 协议（ws/wss） |
| 消息格式 | 仅文本（需手动序列化二进制）  | 支持文本/二进制                 |
| 重连机制 | 内置（可自定义）              | 需手动实现                      |
| 兼容性   | IE 不支持，其他主流浏览器支持 | 主流浏览器均支持（IE10+）       |
| 资源消耗 | 低（HTTP 长连接）             | 稍高（独立协议）                |
| 跨域处理 | 常规 CORS 配置                | 需单独配置跨域                  |

**适用场景**：

- SSE：单向推送场景（如实时监控、行情、日志、通知），无需双向通信，追求低成本、易维护；
- WebSocket：双向实时交互（如在线聊天、协同编辑、游戏、实时弹幕）。

#### 2. SSE 和轮询（短轮询/长轮询）相比，有哪些优势和劣势？

**参考答案**：

##### 优势（对比轮询）：

1. 低延迟：服务器有数据时立即推送，无需客户端定时请求；
2. 低资源消耗：单个长连接替代多次短连接，减少 TCP 握手/挥手、HTTP 头开销；
3. 内置重连：无需前端写重连逻辑，且支持`Last-Event-ID`补发消息；
4. 服务端可控：可自定义重连间隔、事件类型，更灵活。

##### 劣势：

1. 仅单向推送：无法替代长轮询的双向交互能力；
2. 连接数限制：HTTP/1.1 下单个域名默认 6 个并发连接，大量客户端时需优化（如域名分片）；
3. 中间件兼容：部分代理/防火墙可能拦截长连接，需配置超时时间。

#### 3. SSE 和 HTTP/2 的服务器推送（Server Push）是一回事吗？为什么？

**参考答案**：
不是同一回事，核心区别：

1. 用途不同：
   - SSE：服务器向客户端推送**动态业务数据**（如实时消息、行情），连接持续且可多次推送；
   - HTTP/2 Server Push：服务器预判客户端需要的静态资源（如 CSS/JS/图片），在客户端请求 HTML 时主动推送，仅针对静态资源，且是“一次性”推送（基于单次请求）。
2. 通信模式不同：
   - SSE：单工、长连接、流式推送；
   - HTTP/2 Push：基于 HTTP/2 的多路复用，针对单次请求推送多个静态资源，无长连接持续推送能力。
3. 适用场景不同：
   - SSE：实时动态数据；
   - HTTP/2 Push：优化静态资源加载（减少客户端请求数）。

### 五、性能优化题

#### 1. 大量客户端使用 SSE 时，服务器会面临哪些压力？如何优化？

**参考答案**：

##### 核心压力：

1. 连接数压力：每个客户端一个长连接，服务器文件描述符（FD）耗尽；
2. 内存压力：每个连接需维护定时器/状态，大量连接导致内存占用过高；
3. 网络压力：广播消息时（如全量推送），服务器带宽/CPU 消耗大。

##### 优化方案：

1. 连接层面：
   - 使用 HTTP/2：多路复用，单个 TCP 连接承载多个 SSE 流，减少 FD 占用；
   - 连接复用/池化：针对客户端集群，减少无效长连接；
   - 超时清理：设置空闲连接超时（如 30 秒无数据则断开，客户端重连）。
2. 推送层面：
   - 批量推送：合并小消息，减少分块传输的开销；
   - 按需推送：基于订阅（如客户端只订阅关注的行情），避免全量广播；
   - 集群化：使用消息队列（如 Redis Pub/Sub、Kafka）实现 SSE 集群推送，避免单节点压力；
3. 基础设施：
   - 反向代理优化：Nginx 配置`proxy_set_header Connection "";`、`proxy_read_timeout 86400s`，支持长连接；
   - 水平扩容：多节点部署，通过负载均衡分发连接。

#### 2. 如何减少 SSE 连接的资源消耗？

**参考答案**：

1. 心跳优化：合理设置心跳间隔（如 30 秒一次），避免过于频繁的心跳包；
2. 空闲断开：客户端/服务器检测到长时间无数据（如 5 分钟），主动断开连接，有数据时再重连；
3. 共享连接：针对同域名下的多个 SSE 需求，合并为一个连接（通过`event`字段区分不同业务）；
4. 轻量级消息：压缩消息体（如 gzip），减少传输数据量；
5. 资源释放：后端监听`close`事件，及时清理定时器、缓存等资源，避免内存泄漏；
6. 限流：限制单客户端的重连频率，防止恶意重连占用资源。

#### 3. SSE 推送的数据量较大时，如何优化传输效率？

**参考答案**：

1. 数据压缩：服务器开启 gzip/brotli 压缩（响应头`Content-Encoding: gzip`），减少传输体积；
2. 数据序列化：使用更轻量的格式（如 MessagePack）替代 JSON，减少序列化后的数据长度；
3. 分批次推送：将大文件/大数据拆分为多个 SSE 消息块，避免单次推送过大导致阻塞；
4. 按需推送：只推送变化的字段（如增量更新），而非全量数据；
5. 二进制传输：SSE 本身仅支持文本，可将二进制数据 Base64 编码后传输（或降级为 WebSocket）；
6. 网络优化：使用 CDN 加速，减少跨地域传输延迟。

### 六、问题排查题

#### 1. 前端接收不到 SSE 推送的消息，可能有哪些原因？如何排查？

**参考答案**：

##### 常见原因：

1. 响应头配置错误：未设置`Content-Type: text/event-stream`，或`Cache-Control`未设为`no-cache`；
2. 消息格式错误：缺少空行分隔消息、`data`字段格式错误、特殊字符未转义；
3. 跨域问题：后端未配置`Access-Control-Allow-Origin`，或未允许`Last-Event-ID`请求头；
4. 连接被中断：Nginx/代理的`proxy_read_timeout`过短，断开长连接；
5. 服务器未发送数据：定时器未启动、业务逻辑异常导致无数据推送；
6. 前端监听错误：未监听正确的事件类型（如自定义`event`未对应）。

##### 排查步骤：

1. 浏览器 Network 面板：查看 SSE 请求的响应头是否包含`text/event-stream`、`no-cache`；
2. 查看响应体：确认消息格式是否符合`字段: 值`+空行的规范；
3. 检查控制台：是否有跨域错误、JS 语法错误；
4. 后端日志：确认服务器是否正常发送数据，是否监听到客户端连接；
5. 测试代理配置：临时关闭 Nginx 等代理，直连服务器验证是否正常。

#### 2. SSE 连接频繁断开重连，可能的原因是什么？怎么解决？

**参考答案**：

##### 常见原因：

1. 服务器/代理超时：Nginx`proxy_read_timeout`、Tomcat`connectionTimeout`过短；
2. 无心跳保活：长时间无业务数据，中间件/防火墙主动断开连接；
3. 网络不稳定：客户端网络波动导致连接中断；
4. 服务器资源不足：FD 耗尽、内存溢出导致强制断开连接；
5. 前端未处理`close`事件：意外断开后触发默认重连，形成循环。

##### 解决方法：

1. 延长超时时间：Nginx 配置`proxy_read_timeout 3600s`，后端设置长连接超时；
2. 增加心跳：服务器每 30 秒发送注释行（`: heartbeat\n\n`），维持连接；
3. 自定义重连策略：前端实现指数退避重连（如 1s→2s→4s→8s，上限 60s），避免频繁重连；
4. 服务器扩容：增加 FD 上限（如 Linux`ulimit -n 65535`），优化内存占用；
5. 网络优化：使用 WebSocket 降级方案，或增加断连提示。

#### 3. 跨域场景下使用 SSE 需要注意什么？如何解决跨域问题？

**参考答案**：

##### 注意事项：

1. 浏览器会先发 OPTIONS 预检请求（若自定义请求头/方法），需后端支持；
2. SSE 重连时的`Last-Event-ID`请求头，需后端允许该头跨域；
3. 部分浏览器限制跨域 SSE 的重连机制，需确保 CORS 配置完整。

##### 解决方法（后端配置 CORS）：

以 Node.js 为例：

```javascript
res.setHeader("Access-Control-Allow-Origin", "https://your-frontend.com"); // 允许指定域名（*为通配）
res.setHeader("Access-Control-Allow-Methods", "GET"); // SSE仅需GET
res.setHeader("Access-Control-Allow-Headers", "Last-Event-ID"); // 允许重连的ID头
res.setHeader("Access-Control-Max-Age", "86400"); // 预检请求缓存时间，减少OPTIONS请求
```

若使用 Nginx 反向代理：

```nginx
location /api/sse {
  proxy_pass http://backend:3000;
  add_header Access-Control-Allow-Origin "https://your-frontend.com";
  add_header Access-Control-Allow-Headers "Last-Event-ID";
  add_header Access-Control-Allow-Methods "GET";
}
```

### 七、进阶拓展题

#### 1. SSE 是否支持双向通信？如果需要双向通信该如何处理？

**参考答案**：
SSE 本身是**单工通信**，仅支持服务器 → 客户端推送，不直接支持双向通信。
实现双向通信的方案：

1. 结合 HTTP 请求：客户端通过 AJAX/Fetch 发送请求（如 POST）传递数据给服务器，服务器通过 SSE 推送响应/结果；
2. 降级为 WebSocket：若双向通信需求频繁，直接使用 WebSocket 更高效；
3. 混合方案：SSE 负责服务器主动推送，WebSocket 负责客户端主动发送，按需选择。

#### 2. 在分布式系统中，如何实现 SSE 的集群推送（比如某台服务器触发事件，所有连接的客户端都能收到）？

**参考答案**：
核心思路：引入**消息中间件**实现集群内事件广播，步骤如下：

1. 客户端连接任意 SSE 服务器节点（Node1/Node2/Node3）；
2. 每个 SSE 节点启动时订阅消息队列（如 Redis Pub/Sub、Kafka、RabbitMQ）的指定频道；
3. 当某节点（如 Node1）接收到业务事件（如订单创建），将事件发布到消息队列；
4. 所有 SSE 节点收到队列的事件后，通过自身的 SSE 连接推送给对应的客户端；
5. 可选优化：基于客户端 ID/订阅主题做消息过滤，避免全量推送。

示例（Redis Pub/Sub）：

```javascript
// 服务器发布事件
const redis = require("redis");
const publisher = redis.createClient();
publisher.publish(
  "sse_updates",
  JSON.stringify({ type: "order", data: "xxx" })
);

// 每个SSE节点订阅事件
const subscriber = redis.createClient();
subscriber.subscribe("sse_updates");
subscriber.on("message", (channel, message) => {
  // 推送给当前节点的所有SSE客户端
  clients.forEach((client) => {
    client.write(`data: ${message}\n\n`);
  });
});
```

#### 3. SSE 的消息可靠性如何保证？如果客户端断连期间的消息丢失，该如何处理？

**参考答案**：
SSE 本身不保证消息 100%可靠，需通过以下机制增强可靠性：

1. 消息 ID 机制：
   - 服务器为每个消息分配唯一`id`，客户端记录`lastEventId`；
   - 重连时客户端携带`Last-Event-ID`，服务器据此查询未推送的消息并补发；
2. 消息持久化：
   - 服务器将待推送的消息持久化到数据库/缓存（如 Redis），保留一定时间（如 1 小时）；
   - 客户端重连时，服务器根据`Last-Event-ID`从持久化存储中获取丢失的消息；
3. 确认机制：
   - 客户端接收消息后，通过 HTTP 请求向服务器发送确认（如`POST /ack?id=1001`）；
   - 服务器标记已确认的消息，未确认的消息在客户端重连时补发；
4. 兜底策略：
   - 限制消息重补发范围（如仅补发 30 分钟内的消息）；
   - 关键消息通过其他渠道（如短信、推送）兜底。

#### 4. 如何在 SSE 中实现消息的优先级推送？

**参考答案**：
核心思路：对消息分类标记优先级，服务器按优先级排序推送，步骤如下：

1. 消息分级：定义优先级（如高：1、中：2、低：3），比如“系统告警”为高优先级，“行情更新”为中优先级；
2. 服务器端维护优先级队列：每个客户端连接对应多个消息队列（高/中/低），新消息按优先级入队；
3. 推送策略：服务器优先消费高优先级队列的消息，再处理中/低优先级；
4. 前端监听优先级事件：通过`event`字段区分优先级（如`event: high-priority`），前端优先处理高优先级消息。

示例（服务器端）：

```javascript
// 每个客户端的优先级队列
const clientQueues = {
  high: [],
  medium: [],
  low: [],
};

// 入队
function enqueueMessage(priority, data) {
  clientQueues[priority].push(data);
}

// 消费队列（优先高优先级）
function consumeQueue(res) {
  if (clientQueues.high.length > 0) {
    const msg = clientQueues.high.shift();
    res.write(`event: high-priority\n`);
    res.write(`data: ${JSON.stringify(msg)}\n\n`);
  } else if (clientQueues.medium.length > 0) {
    const msg = clientQueues.medium.shift();
    res.write(`event: medium-priority\n`);
    res.write(`data: ${JSON.stringify(msg)}\n\n`);
  } else if (clientQueues.low.length > 0) {
    const msg = clientQueues.low.shift();
    res.write(`event: low-priority\n`);
    res.write(`data: ${JSON.stringify(msg)}\n\n`);
  }
}

// 定时消费
setInterval(() => consumeQueue(res), 100);
```
