# 模拟面试题组

好的，我们来一次深度模拟。这里不仅包含问题，更重要的是提供一个 **2-2 级别工程师应该给出的答案思路、深度和广度**。请记住，面试官更看重你的思考过程，而不是背诵标准答案。

### **第一部分：JavaScript 基础与深度**

#### **问题 1：请深入解释一下 JavaScript 的闭包，以及它在实际开发中的应用和潜在问题。**

**标准回答 (避免):**

> 闭包就是一个函数能够访问其外部作用域的变量。
> **2-2 级别回答思路:**
> “好的，我们从定义、原理、应用和问题四个层面来聊一下闭包。”
>
> **1. 定义与原理:**
> “闭包的本质是 JavaScript 函数作用域链产生的一种现象。当一个内部函数引用了其外部函数作用域中的变量时，就形成了一个闭包。关键在于，即使外部函数已经执行完毕，其作用域链并不会被销毁，因为内部函数仍然保持着对它的引用。这使得这些变量可以持续存在于内存中，不会被垃圾回收机制回收。”
>
> **2. 实际应用 (这是重点，体现工程经验):**
> “闭包在前端开发中非常常见，它解决了几个核心问题：”
>
> - **数据私有化和状态封装**：“这是最经典的应用。比如，我们可以用闭包来创建一个私有计数器，外部无法直接修改计数值，只能通过暴露的特定方法来操作，这符合软件工程的最小暴露原则。”

```js
/ 外部函数：封装私有状态（count），返回操作方法（闭包）
function createCounter(initialValue = 0) {
  // 私有变量：仅内部函数可访问，外部无法直接修改
  let count = initialValue;

  // 暴露的操作方法（闭包）：引用了外部的count变量
  return {
    increment: () => { count += 1; }, // 递增
    decrement: () => { count = Math.max(0, count - 1); }, // 递减（防止负数）
    getCount: () => count, // 获取当前值（只读）
    reset: () => { count = initialValue; } // 重置（可选暴露）
  };
}

// 使用示例
const counter1 = createCounter(10); // 初始值10
counter1.increment(); // 操作：加1
counter1.increment(); // 操作：加1
counter1.decrement(); // 操作：减1
console.log(counter1.getCount()); // 输出：11（外部只能通过getCount获取）
console.log(counter1.count); // 输出：undefined（外部无法直接访问私有变量）

// 多个计数器独立（闭包隔离状态）
const counter2 = createCounter(0);
counter2.increment();
console.log(counter2.getCount()); // 输出：1（与counter1互不影响）
```

> - **函数柯里化**：“通过闭包，我们可以将一个多参数函数转换成一系列单参数函数。这在函数式编程和配置复用中非常有用，比如创建一个带有特定配置的 API 请求函数。”

```js
// 普通多参数函数：接收 2 个参数，直接执行
function add(a, b) {
  return a + b;
}
add(1, 2); // 输出：3（直接传所有参数）

// 柯里化改造（基于闭包）：拆分为 2 个单参数函数
function curriedAdd(a) {
  // 闭包保留第一个参数 a
  return function (b) {
    // 接收第二个参数 b，参数凑齐后执行计算
    return a + b;
  };
}

// 调用方式：链式传递参数，直到凑齐
const add1 = curriedAdd(1); // 保存参数 1，返回接收 b 的函数
add1(2); // 传入参数 2，凑齐执行 → 输出 3
curriedAdd(3)(4); // 直接链式调用 → 输出 7
```

> - **防抖与节流**：“这两个性能优化函数的核心就是闭包。它们通过闭包保存了 `timer`、`lastTime` 等状态信息，使得在多次函数调用之间能够共享和记忆这些状态，从而控制函数的执行频率。”
>
> **3. 潜在问题与解决方案 (体现深度和严谨性):**
> “闭包最主要的潜在问题是**内存泄漏**。因为闭包会阻止其引用的外部变量被垃圾回收，如果闭包被长期引用，而这些变量又包含大量数据或不再需要的数据，就会导致内存占用持续增高。”
>
> - **解决方案**：“解决这个问题的关键在于**及时解除引用**。在不再需要闭包时，我们可以将引用闭包的变量设置为 `null`。例如，在单页应用中，当一个组件被卸载时，如果它内部的事件回调（一个闭包）引用了组件的实例，我们需要在组件的 `unmount` 生命周期中清除这些事件监听器，从而断开引用链，让 GC 可以正常工作。”
>   **追问:**
>   “那请你手写一个支持立即执行的 `debounce` 函数。”
>   **回答:**
>   “好的，这是一个典型的应用场景。我会实现一个 `debounce` 函数，它接受一个函数 `func` 和延迟时间 `wait`，以及一个控制是否立即执行的布尔值 `immediate`。”
>
> ```javascript
> function debounce(func, wait, immediate = false) {
>   let timer = null;
>
>   return function (...args) {
>     const callNow = immediate && !timer;
>
>     // 如果存在定时器，则清除
>     if (timer) clearTimeout(timer);
>
>     // 如果是立即执行模式
>     if (callNow) {
>       func.apply(this, args);
>     }
>
>     // 重新设置定时器，wait 后执行
>     timer = setTimeout(() => {
>       // 非立即执行模式下，在 wait 后执行
>       if (!immediate) {
>         func.apply(this, args);
>       }
>       // 执行完毕后，将 timer 重置为 null
>       timer = null;
>     }, wait);
>   };
> }
> ```
>
> “这里有几个关键点：
>
> 1.  使用 `...args` 和 `apply` 来保证 `this` 的正确指向和参数的传递。
> 2.  `callNow` 变量是处理 `immediate` 模式的核心，它确保在触发事件的第一时间执行一次。
> 3.  每次触发都会清除旧的 `timer` 并设置新的，确保只有在最后一次触发后 `wait` 毫秒才会执行。
> 4.  在 `setTimeout` 的回调里将 `timer` 设为 `null`，这是一个好习惯，有助于内存回收。”

---

### **第二部分：浏览器与网络**

#### **问题 2：从用户在浏览器地址栏输入 URL 并回车，到页面完整展示，中间发生了什么？请尽可能详细地描述，并说出可以优化的点。**

**2-2 级别回答思路:**

> “这个过程非常复杂，可以分为三大阶段：**网络请求、服务器响应、浏览器渲染**。我会逐一拆解。”
> **1. 网络请求阶段:**
>
> - **URL 解析**：“浏览器首先判断输入的是搜索关键词还是 URL。如果是 URL，会解析出协议、域名、端口、路径等信息。”
> - **DNS 查询**：“浏览器缓存 -> 系统缓存 -> 路由器缓存 -> ISP DNS 服务器 -> 根域名服务器... 这是一个递归查询的过程。**优化点**：使用 DNS 预取 (`<link rel="dns-prefetch">`) 和 HTTPDNS 来减少查询时间。”
> - **TCP 连接**：“三次握手建立连接。**优化点**：TCP 预连接，或者使用 HTTP/2 的多路复用来减少连接数。”
> - **HTTP 请求**：“浏览器构建请求行、请求头、请求体（如果是 POST 请求），然后发送。**优化点**：减少 Cookie 体积，使用 HTTP/2 的头部压缩。”
>   **2. 服务器响应阶段:**
> - “服务器处理请求，可能涉及负载均衡、API 网关、业务逻辑处理、数据库查询等，最终返回 HTTP 响应。**优化点**：这是后端优化的范畴，比如使用 CDN 缓存静态资源、数据库索引、缓存（Redis）等。”
>   **3. 浏览器渲染阶段 (关键渲染路径 CRP):**
> - **处理 HTML 构建 DOM 树**：“浏览器从上到下解析 HTML，将标签转换成 DOM 节点，构建成 DOM 树。”
> - **处理 CSS 构建 CSSOM 树**：“解析 CSS，构建 CSSOM 树。**注意**：CSS 会阻塞渲染，但不会阻塞 DOM 解析。**优化点**：将 CSS 放在 `<head>` 中，尽快加载；使用媒体查询 `media` 属性让非关键 CSS 不阻塞渲染。”
> - **合并构建渲染树**：“将 DOM 树和 CSSOM 树合并，生成渲染树，只包含需要渲染的节点。”
> - **布局**：“根据渲染树，计算每个节点在屏幕上的确切位置和大小（几何信息）。这是一个耗时的操作。**优化点**：避免频繁触发布局（回流），比如使用 `transform` 和 `opacity` 代替 `top` 和 `width` 的修改。”
> - **绘制**：“将节点绘制成屏幕上的实际像素。**优化点**：减少绘制区域，使用 `will-change` 属性提示浏览器。”
> - **合成**：“将各层合并到一起，显示在屏幕上。**优化点**：利用分层合成机制，对动画元素使用 `transform: translateZ(0)` 或 `will-change: transform` 创建新的渲染层，避免整个页面的重绘。”
>   **总结优化策略:**
> - **网络层**：HTTP/2、CDN、缓存、减少请求数量。
> - **渲染层**：关键 CSS 内联、非关键 CSS 异步加载、图片懒加载、骨架屏。
> - **脚本层**：`<script defer async>`，避免 JS 阻塞解析。

---

### **第三部分：框架与工程化**

#### **问题 3：React Hooks 解决了什么问题？为什么不能在条件语句中使用 Hooks？**

**2-2 级别回答思路:**

> “React Hooks 的引入是 React 发展史上一个里程碑，它主要解决了 Class 组件的几个核心痛点。”
> **1. Hooks 解决的问题:**
>
> - **组件逻辑复用困难**：“在 Hooks 出现前，我们主要使用高阶组件和 Render Props 来复用逻辑，但这会导致‘嵌套地狱’，使组件树变得非常复杂且难以调试。Hooks 通过自定义 Hook，可以将相关逻辑（如数据获取、状态管理）封装到一个函数中，在组件间共享，且不会改变组件结构，代码更扁平、清晰。”
> - **巨型组件难以维护**：“Class 组件中，相关的逻辑常常被分散在不同的生命周期方法中（如 `componentDidMount` 获取数据，`componentDidUpdate` 处理更新）。Hooks 则允许我们根据逻辑功能来组织代码，将相关的状态和副作用都放在同一个自定义 Hook 中，实现了关注点分离。”
> - **Class 的复杂性**：“Class 组件对新手不友好，需要理解 `this` 指向、绑定事件等。Hooks 让我们可以在函数组件中使用状态和其他 React 特性，写法更简洁，更符合函数式编程的思想。”
>   **2. 为什么不能在条件语句中使用 Hooks:**
>   “这个规则的根本原因在于 **React 需要保证 Hooks 的调用顺序在每次渲染中都是完全一致的**。”
> - **工作原理**：“React 并不知道你哪个 `useState` 对应哪个 state。它的实现方式是，在首次渲染时，按顺序创建一个 Hook 链表，并将其挂载到对应的 Fiber 节点上。当你调用 `useState` 时，React 就从链表中取出当前对应的 Hook。”
> - **如果顺序被打乱**：“假设我们第一次渲染时调用了 `hookA`, `hookB`, `hookC`。如果在某次渲染中，因为 `if` 条件，`hookB` 没有被执行，那么 React 在取 Hook 时，原本应该是 `hookB` 的位置现在取到的是 `hookC`。这会导致状态错乱、渲染错误，甚至应用崩溃。”
> - **总结**：“所以，‘只能在顶层调用 Hooks’ 这条规则，不是 React 的限制，而是其实现机制的根本要求。React 官方的 ESLint 插件 `eslint-plugin-react-hooks` 就是专门用来强制执行这条规则的。”

---

### **第四部分：数据结构与算法**

#### **问题 4：设计并实现一个 LRU (Least Recently Used) 缓存机制。**

**2-2 级别回答思路:**

> “好的，LRU 缓存是一种常用的页面置换算法，它的核心思想是‘最近最少使用’的数据被淘汰。要实现 `get` 和 `put` 操作都为 O(1) 的时间复杂度，我们需要结合两种数据结构：**哈希表** 和 **双向链表**。”
> **1. 数据结构选择:**
>
> - **哈希表**：“用于存储键到值的映射，并能以 O(1) 的时间复杂度通过 key 找到对应的节点。但哈希表是无序的，无法快速找到最近最少使用的元素。”
> - **双向链表**：“用于维护节点的使用顺序。最近访问的节点放在链表头部，尾部就是最近最少使用的节点。双向链表的优点是，当我们访问一个节点时，可以以 O(1) 的时间复杂度将其从当前位置移动到头部。当需要淘汰时，直接移除尾部节点即可。”
>   **2. 实现思路:**
> - **`get(key)`**：
>   1.  通过哈希表查找 key 对应的节点。
>   2.  如果节点不存在，返回 -1。
>   3.  如果节点存在，将该节点从链表当前位置移动到链表头部，表示它被最近访问了。
>   4.  返回节点的值。
> - **`put(key, value)`**： 1. 通过哈希表查找 key 是否已存在。 2. 如果存在，更新该节点的值，并将其移动到链表头部。 3. 如果不存在，创建一个新节点：
>   _ 将其添加到链表头部。
>   _ 在哈希表中添加该 key 和新节点的映射。 \* 检查缓存是否已满。如果已满，移除链表尾部节点，并在哈希表中删除对应的 key。
>   **3. 代码实现:**
>
> ```javascript
> class ListNode {
>   constructor(key, value) {
>     this.key = key;
>     this.value = value;
>     this.prev = null;
>     this.next = null;
>   }
> }
>
> class LRUCache {
>   constructor(capacity) {
>     this.capacity = capacity;
>     this.cache = new Map(); // 使用 Map 作为哈希表
>     this.head = new ListNode(0, 0); // 虚拟头节点
>     this.tail = new ListNode(0, 0); // 虚拟尾节点
>     this.head.next = this.tail;
>     this.tail.prev = this.head;
>   }
>
>   _removeNode(node) {
>     node.prev.next = node.next;
>     node.next.prev = node.prev;
>   }
>
>   _addToHead(node) {
>     node.next = this.head.next;
>     node.prev = this.head;
>     this.head.next.prev = node;
>     this.head.next = node;
>   }
>
>   get(key) {
>     if (this.cache.has(key)) {
>       const node = this.cache.get(key);
>       this._removeNode(node);
>       this._addToHead(node);
>       return node.value;
>     }
>     return -1;
>   }
>
>   put(key, value) {
>     if (this.cache.has(key)) {
>       const node = this.cache.get(key);
>       node.value = value; // 更新值
>       this._removeNode(node);
>       this._addToHead(node);
>     } else {
>       const newNode = new ListNode(key, value);
>       this.cache.set(key, newNode);
>       this._addToHead(newNode);
>
>       if (this.cache.size > this.capacity) {
>         const tailNode = this.tail.prev;
>         this._removeNode(tailNode);
>         this.cache.delete(tailNode.key);
>       }
>     }
>   }
> }
> ```
>
> “我使用了虚拟头尾节点来简化边界条件的处理，使 `_removeNode` 和 `_addToHead` 操作无需判断节点是否为头尾。”

---

### **第五部分：系统设计**

---
